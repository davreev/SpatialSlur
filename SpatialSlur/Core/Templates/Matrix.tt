<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>
<#@ import namespace="System.Collections.Generic" #>
<#
// Type array
var rowTypes = new string[]{"Vector2d", "Vector3d"};

// Table of row type properties
var rowProperties = new Dictionary<string, Dictionary<string, string>>()
{
    {
        "Vector2d", new Dictionary<string, string>()
        {
            {"Scalar", "double"},
            {"Dimension", "2"}
        }
    },
    {
        "Vector3d", new Dictionary<string, string>()
        {              
            {"Scalar", "double"},
            {"Dimension", "3"}
        }
    },
    {
        "Vector4d", new Dictionary<string, string>()
        {              
            {"Scalar", "double"},
            {"Dimension", "4"}
        }
    }
};

// Table of scalar type properties
var scalarProperties = new Dictionary<string, Dictionary<string, string>>()
{
    {
        "double", new Dictionary<string, string>()
        {
            {"Suffix", "d"},             
            {"Epsilon", "Constd.ZeroTolerance"}
        }
    },
    {
        "float", new Dictionary<string, string>()
        {              
            {"Suffix", "f"},             
            {"Epsilon", "Constf.ZeroTolerance"}
        }
    }
};
#>

/*
 * Notes
 */

using System;
using System.Collections.Generic;
using System.Collections.Concurrent;
using System.Linq;
using System.Text;
using System.Drawing;

using SpatialSlur.Collections;

using static System.Threading.Tasks.Parallel;

using Constd = SpatialSlur.SlurMath.Constantsd;
using Constf = SpatialSlur.SlurMath.Constantsf;

namespace SpatialSlur
{
	/// <summary>
	///
	/// </summary>
	public static partial class Matrix
    {
        /// <summary>
        ///
        /// </summary>
        public static partial class RowWise
        {
            /// <summary>
            /// Contains parallel implementations
            /// </summary>
            public static partial class Parallel
            {
<#
foreach(string rowType in rowTypes) 
{
    var rowProps= rowProperties[rowType];
    var valType = rowProps["Scalar"];
    var dim = rowProps["Dimension"];

    var valProps = scalarProperties[valType];
    var suf = valProps["Suffix"];
    var eps = valProps["Epsilon"];
        
    var matIn = $"ReadOnlyArrayView<{rowType}>";
    var matOut = $"ArrayView<{rowType}>";

    var vecIn = $"ReadOnlyArrayView<{valType}>";
    var vecOut = $"ArrayView<{valType}>";
#>

                #region <#= rowType #>

                /// <summary>
                /// 
                /// </summary>
                public static void Abs(<#= matIn #> matrix, <#= matOut #> result)
                {
                    ForEach(new UniformPartitioner(0, matrix.Count), p =>
                    {
                        for (int i = p.From; i < p.To; i++)
                            result[i] = <#= rowType #>.Abs(matrix[i]);
                    });
                }


                /// <summary>
                /// 
                /// </summary>
                public static void Max(<#= matIn #> m0, <#= matIn #> m1, <#= matOut #> result)
                {
                    ForEach(new UniformPartitioner(0, m0.Count), p =>
                    {
                        for (int i = p.From; i < p.To; i++)
                            result[i] = <#= rowType #>.Max(m0[i], m1[i]);
                    });
                }


                /// <summary>
                /// 
                /// </summary>
                public static void Min(<#= matIn #> m0, <#= matIn #> m1, <#= matOut #> result)
                {
                    ForEach(new UniformPartitioner(0, m0.Count), p =>
                    {
                        for (int i = p.From; i < p.To; i++)
                            result[i] = <#= rowType #>.Min(m0[i], m1[i]);
                    });
                }


                /// <summary>
                /// 
                /// </summary>
                public static void Add(<#= matIn #> m0, <#= matIn #> m1, <#= matOut #> result)
                {
                    ForEach(new UniformPartitioner(0, m0.Count), p =>
                    {
                        for (int i = p.From; i < p.To; i++)
                            result[i] = m0[i] + m1[i];
                    });
                }


                /// <summary>
                /// 
                /// </summary>
                public static void Subtract(<#= matIn #> m0, <#= matIn #> m1, <#= matOut #> result)
                {
                    ForEach(new UniformPartitioner(0, m0.Count), p =>
                    {
                        for (int i = p.From; i < p.To; i++)
                            result[i] = m0[i] - m1[i];
                    });
                }


                /// <summary>
                /// 
                /// </summary>
                public static void Multiply(<#= matIn #> matrix, <#= valType #> scalar, <#= matOut #> result)
                {
                    ForEach(new UniformPartitioner(0, matrix.Count), p =>
                    {
                        for (int i = p.From; i < p.To; i++)
                            result[i] = matrix[i] * scalar;
                    });
                }


                /// <summary>
                ///
                /// </summary>
                public static void Multiply(<#= matIn #> matrix, <#= vecIn #> vector, <#= matOut #> result)
                {
                    ForEach(new UniformPartitioner(0, matrix.Count), p =>
                    {
                        for (int i = p.From; i < p.To; i++)
                            result[i] = matrix[i] * vector[i];
                    });
                }


                /// <summary>
                ///
                /// </summary>
                public static void Multiply(<#= matIn #> m0, <#= matIn #> m1, <#= matOut #> result)
                {
                    ForEach(new UniformPartitioner(0, m0.Count), p =>
                    {
                        for (int i = p.From; i < p.To; i++)
                            result[i] = m0[i] * m1[i];
                    });
                }


                /// <summary>
                ///
                /// </summary>
                public static void Divide(<#= matIn #> matrix, <#= vecIn #> vector, <#= matOut #> result)
                {
                    ForEach(new UniformPartitioner(0, matrix.Count), p =>
                    {
                        for (int i = p.From; i < p.To; i++)
                            result[i] = matrix[i] / vector[i];
                    });
                }


                /// <summary>
                /// 
                /// </summary>
                public static void Divide(<#= matIn #> m0, <#= matIn #> m1, <#= matOut #> result)
                {
                    ForEach(new UniformPartitioner(0, m0.Count), p =>
                    {
                        for (int i = p.From; i < p.To; i++)
                            result[i] = m0[i] / m1[i];
                    });
                }


                /// <summary>
                /// result = m0 + m1 * t
                /// </summary>
                public static void AddScaled(<#= matIn #> m0, <#= matIn #> m1, <#= valType #> t, <#= matOut #> result)
                {
                    ForEach(new UniformPartitioner(0, m0.Count), p =>
                    {
                        for (int i = p.From; i < p.To; i++)
                            result[i] = m0[i] + m1[i] * t;
                    });
                }


                /// <summary>
                /// result = m0 + m1 * t
                /// </summary>
                public static void AddScaled(<#= matIn #> m0, <#= matIn #> m1, <#= vecIn #> t, <#= matOut #> result)
                {
                    ForEach(new UniformPartitioner(0, m0.Count), p =>
                    {
                        for (int i = p.From; i < p.To; i++)
                            result[i] = m0[i] + m1[i] * t[i];
                    });
                }


                /// <summary>
                /// result = m0 * t0 + m1 * t1
                /// </summary>
                public static void AddScaled(<#= matIn #> m0, <#= valType #> t0, <#= matIn #> m1, <#= valType #> t1, <#= matOut #> result)
                {
                    ForEach(new UniformPartitioner(0, m0.Count), p =>
                    {
                        for (int i = p.From; i < p.To; i++)
                            result[i] = m0[i] * t0 + m1[i] * t1;
                    });
                }


                /// <summary>
                /// result = m0 * t0 + m1 * t1
                /// </summary>
                public static void AddScaled(<#= matIn #> m0, <#= vecIn #> t0, <#= matIn #> m1, <#= vecIn #> t1, <#= matOut #> result)
                {
                    ForEach(new UniformPartitioner(0, m0.Count), p =>
                    {
                        for (int i = p.From; i < p.To; i++)
                            result[i] = m0[i] * t0[i] + m1[i] * t1[i];
                    });
                }


                /// <summary>
                /// result = m0 + (m1 - m2) * t
                /// </summary>
                public static void AddScaledDelta(<#= matIn #> m0, <#= matIn #> m1, <#= matIn #> m2, <#= valType #> t, <#= matOut #> result)
                {
                    ForEach(new UniformPartitioner(0, m0.Count), p =>
                    {
                        for (int i = p.From; i < p.To; i++)
                            result[i] = m0[i] + (m1[i] - m2[i]) * t;
                    });
                }


                /// <summary>
                /// result = m0 + (m1 - m2) * t
                /// </summary>
                public static void AddScaledDelta(<#= matIn #> m0, <#= matIn #> m1, <#= matIn #> m2, <#= vecIn #> t, <#= matOut #> result)
                {
                    ForEach(new UniformPartitioner(0, m0.Count), p =>
                    {
                        for (int i = p.From; i < p.To; i++)
                            result[i] = m0[i] + (m1[i] - m2[i]) * t[i];
                    });
                }


                /// <summary>
                ///
                /// </summary>
                public static void Lerp(<#= matIn #> m0, <#= matIn #> m1, <#= valType #> t, <#= matOut #> result)
                {
                    ForEach(new UniformPartitioner(0, m0.Count), p =>
                    {
                        for (int i = p.From; i < p.To; i++)
                            result[i] = m0[i].LerpTo(m1[i], t);
                    });
                }


                /// <summary>
                /// result = m0 + (m1 - m0) * t
                /// </summary>
                public static void Lerp(<#= matIn #> m0, <#= matIn #> m1, <#= vecIn #> t, <#= matOut #> result)
                {
                    ForEach(new UniformPartitioner(0, m0.Count), p =>
                    {
                        for (int i = p.From; i < p.To; i++)
                            result[i] = m0[i].LerpTo(m1[i], t[i]);
                    });
                }


                /// <summary>
                /// 
                /// </summary>
                public static void Unitize(<#= matIn #> matrix, <#= matOut #> result)
                {
                    ForEach(new UniformPartitioner(0, matrix.Count), p =>
                    {
                        for (int i = p.From; i < p.To; i++)
                            result[i] = matrix[i].Unit;
                    });
                }


                /// <summary>
                ///
                /// </summary>
                public static void Normalize(<#= matIn #> matrix, Interval<#= dim #><#= suf #> interval, <#= matOut #> result)
                {
                    ForEach(new UniformPartitioner(0, matrix.Count), p =>
                    {
                        for (int i = p.From; i < p.To; i++)
                            result[i] = interval.Normalize(matrix[i]);
                    });
                }


                /// <summary>
                ///
                /// </summary>
                public static void Evaluate(<#= matIn #> matrix, Interval<#= dim #><#= suf #> interval, <#= matOut #> result)
                {
                    ForEach(new UniformPartitioner(0, matrix.Count), p =>
                    {
                        for (int i = p.From; i < p.To; i++)
                            result[i] = interval.Evaluate(matrix[i]);
                    });
                }


                /// <summary>
                ///
                /// </summary>
                public static void Remap(<#= matIn #> matrix, Interval<#= dim #><#= suf #> from, Interval<#= dim #><#= suf #> to, <#= matOut #> result)
                {
                    ForEach(new UniformPartitioner(0, matrix.Count), p =>
                    {
                        for (int i = p.From; i < p.To; i++)
                            result[i] = Interval<#= dim #><#= suf #>.Remap(matrix[i], from, to);
                    });
                }

                #endregion

    <#
    }
    #>
        }

    <#
    foreach(string rowType in rowTypes) 
    {
        var rowProps= rowProperties[rowType];
        var valType = rowProps["Scalar"];
        var dim = rowProps["Dimension"];

        var valProps = scalarProperties[valType];
        var suf = valProps["Suffix"];
        var eps = valProps["Epsilon"];
            
        var matIn = $"ReadOnlyArrayView<{rowType}>";
        var matOut = $"ArrayView<{rowType}>";

        var vecIn = $"ReadOnlyArrayView<{valType}>";
        var vecOut = $"ArrayView<{valType}>";
    #>

            #region <#= rowType #>

            /// <summary>
            /// 
            /// </summary>
            public static <#= rowType #> Max(<#= matIn #> matrix)
            {
                var result = matrix[0];

                for (int i = 1; i < matrix.Count; i++)
                    result = <#= rowType #>.Max(matrix[i], result);

                return result;
            }


            /// <summary>
            /// 
            /// </summary>
            public static <#= rowType #> Min(<#= matIn #> matrix)
            {
                var result = matrix[0];

                for (int i = 1; i < matrix.Count; i++)
                    result = <#= rowType #>.Min(matrix[i], result);

                return result;
            }


            /// <summary>
            /// 
            /// </summary>
            public static <#= rowType #> Sum(<#= matIn #> matrix)
            {
                var sum = <#= rowType #>.Zero;

                for (int i = 0; i < matrix.Count; i++)
                    sum += matrix[i];

                return sum;
            }


            /// <summary>
            /// 
            /// </summary>
            public static <#= rowType #> Mean(<#= matIn #> matrix)
            {
                return Sum(matrix) / matrix.Count;
            }


            /// <summary>
            /// 
            /// </summary>
            public static bool ApproxEquals(<#= matIn #> m0, <#= matIn #> m1, <#= valType #> epsilon = <#= eps #>)
            {
                for (int i = 0; i < m0.Count; i++)
                    if (!m0[i].ApproxEquals(m1[i], epsilon)) return false;

                return true;
            }


            /// <summary>
            /// 
            /// </summary>
            public static void Abs(<#= matIn #> matrix, <#= matOut #> result)
            {
                for (int i = 0; i < matrix.Count; i++)
                    result[i] = <#= rowType #>.Abs(matrix[i]);
            }


            /// <summary>
            /// 
            /// </summary>
            public static void Max(<#= matIn #> m0, <#= matIn #> m1, <#= matOut #> result)
            {
                for (int i = 0; i < m0.Count; i++)
                    result[i] = <#= rowType #>.Max(m0[i], m1[i]);
            }


            /// <summary>
            /// 
            /// </summary>
            public static void Min(<#= matIn #> m0, <#= matIn #> m1, <#= matOut #> result)
            {
                for (int i = 0; i < m0.Count; i++)
                    result[i] = <#= rowType #>.Min(m0[i], m1[i]);
            }


            /// <summary>
            /// 
            /// </summary>
            public static void Add(<#= matIn #> m0, <#= matIn #> m1, <#= matOut #> result)
            {
                for (int i = 0; i < m0.Count; i++)
                    result[i] = m0[i] + m1[i];
            }


            /// <summary>
            /// 
            /// </summary>
            public static void Subtract(<#= matIn #> m0, <#= matIn #> m1, <#= matOut #> result)
            {
                for (int i = 0; i < m0.Count; i++)
                    result[i] = m0[i] - m1[i];
            }


            /// <summary>
            /// 
            /// </summary>
            public static void Multiply(<#= matIn #> matrix, <#= valType #> scalar, <#= matOut #> result)
            {
                for (int i = 0; i < matrix.Count; i++)
                    result[i] = matrix[i] * scalar;
            }


            /// <summary>
            ///
            /// </summary>
            public static void Multiply(<#= matIn #> matrix, <#= vecIn #> vector, <#= matOut #> result)
            {
                for (int i = 0; i < matrix.Count; i++)
                    result[i] = matrix[i] * vector[i];
            }


            /// <summary>
            /// 
            /// </summary>
            public static void Multiply(<#= matIn #> m0, <#= matIn #> m1, <#= matOut #> result)
            {
                for (int i = 0; i < m0.Count; i++)
                    result[i] = m0[i] * m1[i];
            }


            /// <summary>
            ///
            /// </summary>
            public static void Divide(<#= matIn #> matrix, <#= vecIn #> vector, <#= matOut #> result)
            {
                for (int i = 0; i < matrix.Count; i++)
                    result[i] = matrix[i] / vector[i];
            }


            /// <summary>
            /// 
            /// </summary>
            public static void Divide(<#= matIn #> m0, <#= matIn #> m1, <#= matOut #> result)
            {
                for (int i = 0; i < m0.Count; i++)
                    result[i] = m0[i] / m1[i];
            }


            /// <summary>
            /// result = m0 + m1 * t
            /// </summary>
            public static void AddScaled(<#= matIn #> m0, <#= matIn #> m1, <#= valType #> t, <#= matOut #> result)
            {
                for (int i = 0; i < m0.Count; i++)
                    result[i] = m0[i] + m1[i] * t;
            }


            /// <summary>
            /// result = m0 + m1 * t
            /// </summary>
            public static void AddScaled(<#= matIn #> m0, <#= matIn #> m1, <#= vecIn #> t, <#= matOut #> result)
            {
                for (int i = 0; i < m0.Count; i++)
                    result[i] = m0[i] + m1[i] * t[i];
            }


            /// <summary>
            /// result = m0 * t0 + m1 * t1
            /// </summary>
            public static void AddScaled(<#= matIn #> m0, <#= valType #> t0, <#= matIn #> m1, <#= valType #> t1, <#= matOut #> result)
            {
                for (int i = 0; i < m0.Count; i++)
                    result[i] = m0[i] * t0 + m1[i] * t1;
            }


            /// <summary>
            /// result = m0 * t0 + m1 * t1
            /// </summary>
            public static void AddScaled(<#= matIn #> m0, <#= vecIn #> t0, <#= matIn #> m1, <#= vecIn #> t1, <#= matOut #> result)
            {
                for (int i = 0; i < m0.Count; i++)
                    result[i] = m0[i] * t0[i] + m1[i] * t1[i];
            }


            /// <summary>
            /// result = m0 + (m1 - m2) * t
            /// </summary>
            public static void AddScaledDelta(<#= matIn #> m0, <#= matIn #> m1, <#= matIn #> m2, <#= valType #> t, <#= matOut #> result)
            {
                for (int i = 0; i < m0.Count; i++)
                    result[i] = m0[i] + (m1[i] - m2[i]) * t;
            }


            /// <summary>
            /// result = m0 + (m1 - m2) * t
            /// </summary>
            public static void AddScaledDelta(<#= matIn #> m0, <#= matIn #> m1, <#= matIn #> m2, <#= vecIn #> t, <#= matOut #> result)
            {
                for (int i = 0; i < m0.Count; i++)
                    result[i] = m0[i] + (m1[i] - m2[i]) * t[i];
            }


            /// <summary>
            ///
            /// </summary>
            public static void Lerp(<#= matIn #> m0, <#= matIn #> m1, <#= valType #> t, <#= matOut #> result)
            {
                for (int i = 0; i < m0.Count; i++)
                    result[i] = m0[i].LerpTo(m1[i], t);
            }


            /// <summary>
            /// result = m0 + (m1 - m0) * t
            /// </summary>
            public static void Lerp(<#= matIn #> m0, <#= matIn #> m1, <#= vecIn #> t, <#= matOut #> result)
            {
                for (int i = 0; i < m0.Count; i++)
                    result[i] = m0[i].LerpTo(m1[i], t[i]);
            }


            /// <summary>
            /// 
            /// </summary>
            public static void Unitize(<#= matIn #> matrix, <#= matOut #> result)
            {
                for (int i = 0; i < matrix.Count; i++)
                    result[i] = matrix[i].Unit;
            }


            /// <summary>
            ///
            /// </summary>
            public static void Normalize(<#= matIn #> matrix, Interval<#= dim #><#= suf #> interval, <#= matOut #> result)
            {
                for (int i = 0; i < matrix.Count; i++)
                    result[i] = interval.Normalize(matrix[i]);
            }


            /// <summary>
            ///
            /// </summary>
            public static void Evaluate(<#= matIn #> matrix, Interval<#= dim #><#= suf #> interval, <#= matOut #> result)
            {
                for (int i = 0; i < matrix.Count; i++)
                    result[i] = interval.Evaluate(matrix[i]);
            }


            /// <summary>
            ///
            /// </summary>
            public static void Remap(<#= matIn #> matrix, Interval<#= dim #><#= suf #> from, Interval<#= dim #><#= suf #> to, <#= matOut #> result)
            {
                for (int i = 0; i < matrix.Count; i++)
                    result[i] = Interval<#= dim #><#= suf #>.Remap(matrix[i], from, to);
            }

            #endregion

<#
}
#>
        }
    }
}